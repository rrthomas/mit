#!/usr/bin/env python3
# Generate front-end.
#
# Copyright (c) 1995-2020 Mit authors
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
# RISK.

from mit_core.code_util import Code, copyright_banner, disable_warnings
from mit_core.spec import MitErrorCode

from features.extra_errors import ExtraInstructionErrorCode


GENERATOR_PROGRAM = 'gen-main'
PURPOSE = 'Command-line front end for Mit.'
COPYRIGHT_YEARS = '1995-2020'


# Command line

class Doc:
    '''
    Free-form documentation.

     - docstring - str or list of str - if the string (or first string)
       starts and ends with a double quote, it is printed literally and may
       thus contain interpolations. Otherwise, it is output in quotes. For a
       list, the other strings are printed literally; they are intended to
       be arguments for `printf` substitutions.
    '''
    elements = []
    def __init__(self, docstring):
        self.elements.append(self)
        if not isinstance(docstring, list):
            docstring = [docstring]
        if docstring[0][:1] != '"' or docstring[0][-1:] != '"':
            docstring[0] = '"{}"'.format(repr(docstring[0])[1:-1])
        self._docstring = docstring

    @property
    def docstring(self):
        return ', '.join(self._docstring)

class Option(Doc):
    '''
    A command-line option.

     - long_name - str - long option name
     - docstring - str - argument docstring as for Doc class.
     - short_name - str - short option char
     - arg - str - 'no_argument' (default), 'required_argument' or
       'optional_argument'
     - arg_name - str - name for the argument, if any
     - parse_code - str - code run when the option is parsed
    '''
    options = []
    def __init__(self, long_name, docstring, short_name=None,
                 arg=None, arg_name=None, parse_code=None):
        super().__init__(docstring)
        self.options.append(self)
        self.long_name = long_name
        self.short_name = short_name
        self.arg = arg or 'no_argument'
        self.arg_name = arg_name
        self.parse_code = parse_code

class Arg(Doc):
    '''
    A command-line argument.

     - arg - str - argument name
     - docstring - str - argument docstring as for Doc class.
    '''
    def __init__(self, arg, docstring):
        super().__init__(docstring)
        self.arg = arg

Doc('Execution:')
Option('memory',
       ['size of memory in words [default %zu]', '(size_t)memory_words'],
       short_name='m',
       arg='required_argument', arg_name='N',
       parse_code=Code('''\
           memory_words = parse_num_words("memory size must be a positive number up to %zu");
       ''')
)

Option('stack',
       ['size of stack in words [default %zu]', '(size_t)stack_words'],
       short_name='s',
       arg='required_argument', arg_name='N',
       parse_code=Code('''\
           stack_words = parse_num_words("stack size must be a positive number up to %zu");
       ''')
)

Option('optimize',
       'use optimizing interpreter',
       short_name='O',
       parse_code=Code('mit_run = mit_run_specializer;'),
)

Doc('\nMiscellaneous:')
Option('help',
       'display this help message and exit',
       parse_code=Code('usage();'),
)

Option('version',
       'display version information and exit',
       parse_code=Code('''\
           {
               printf(PACKAGE_NAME " " VERSION " (%d-byte word, %s-endian)\\n"
                      "Copyright (c) Mit authors 1994-2020.\\n"
                      PACKAGE_NAME " comes with ABSOLUTELY NO WARRANTY.\\n"
                      "You may redistribute copies of " PACKAGE_NAME "\\n"
                      "under the terms of the MIT/X11 License.\\n",
                      MIT_WORD_BYTES, ENDISM_STRING);
               exit(EXIT_SUCCESS);
           }
       ''')
)

Arg('OBJECT-FILE', 'load and run object OBJECT-FILE')
Doc('')
Doc('"The ARGUMENTs are passed to "PACKAGE_NAME"."')
Doc('''
If an error occurs during execution, the exit status is the error code; if
execution halts normally, the exit status is 0. Note that the VM code may
cause an exit with a different status.''')


# Generate output

# Errors
def enum_to_error_table(error_enum):
    code = Code()
    for error in error_enum:
        code.append('{{{}, "{}"}},'.format(
            error.value,
            error.name.lower().translate(str.maketrans('_', ' ')),
        ))
    return code

error_enums = Code()
error_enums.extend(enum_to_error_table(MitErrorCode))
error_enums.extend(enum_to_error_table(ExtraInstructionErrorCode))

# Command-line documentation
help_code = Code()
for element in Doc.elements:
    if isinstance(element, Option):
        arg = ''
        if element.arg_name: arg = element.arg_name
        if element.arg == 'optional_argument':
            arg = '[{}]'.format(arg)
        help_code.append('    printf("  %-26s", "--{long_name}{short_opt} {arg}");'.format(
            long_name=element.long_name,
            short_opt=', -{}'.format(element.short_name) if element.short_name else '',
            arg=arg,
        ))
        help_code.append('    printf({});'.format(element.docstring))
        help_code.append('    putchar(\'\\n\');')
    elif isinstance(element, Arg):
        help_code.append('printf("  %-26s%s\\n", "{arg}", {docstring});'.format(
            arg=element.arg,
            docstring=element.docstring
        ))
    elif isinstance(element, Doc):
        help_code.append('    printf({}"\\n");'.format(element.docstring))

# Command-line options
getopt_code = Code()
shortopts = ''
short_options_code = Code()
long_options_code = Code('')
else_code = ''
for i, option in enumerate(Option.options):
    getopt_code.append('{{"{long_name}", {arg}, NULL, \'{short_name}\'}},'.format(
        long_name=option.long_name, arg=option.arg or '""',
        short_name=option.short_name or "\\0"))
    if option.short_name:
        shortopts += option.short_name
        if option.arg == 'required_argument':
            shortopts += ':'
        elif option.arg == 'optional_argument':
            shortopts += '::'
        short_options_code.append('''\
            else if (c == '{short_name}')
                longindex = {index};'''.format(
                    short_name = option.short_name,
                    index = i
                ))
    if option.parse_code:
        long_options_code.append('{}if (longindex == {})'.format(else_code, i))
        long_options_code.append(option.parse_code)
        else_code = 'else '
getopt_code.append('{0, 0, 0, 0}')
short_options_assignment = Code('const char *shortopts = "+:{}";'.format(shortopts))

# main.c
code = copyright_banner(GENERATOR_PROGRAM, PURPOSE, COPYRIGHT_YEARS)
code.extend(Code('''

#include "config.h"

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <inttypes.h>
#include <errno.h>
#include <getopt.h>
#include <unistd.h>

#include "mit/mit.h"
#include "mit/features.h"

#include "warn.h"


// Error messages
struct {
    int code;
    const char *msg;
} error_msg[] = {
''',
              error_enums,
              '''\
};

static const char *error_to_msg(int code)
{
    for (size_t i = 0; i < sizeof(error_msg) / sizeof(error_msg[0]); i++) {
        if (error_msg[i].code == code)
            return error_msg[i].msg;
    }
    return "unknown error";
}


// Command-line options
#ifdef WORDS_BIGENDIAN
#define ENDISM_STRING "big"
#else
#define ENDISM_STRING "little"
#endif

struct option longopts[] = {''',
              getopt_code,
              '''\
};

static mit_uword parse_num_words(const char *errfmt)
{
    size_t max = SIZE_MAX / MIT_WORD_BYTES;
    char *endptr;
    errno = 0;
    uintmax_t size = strtoumax(optarg, &endptr, 10);
    if (*optarg == '\\0' || *endptr != '\\0' || size == 0 || size > (uintmax_t)max)
        die(errfmt, max);
    return (mit_uword)size;
}

static off_t fleno(FILE *fp)
{
  off_t pos = ftello(fp);
  if (pos != -1 && fseeko(fp, 0, SEEK_END) == 0) {
    off_t len = ftello(fp);
    if (len != -1 && fseeko(fp, pos, SEEK_SET) == 0)
      return len;
  }
  return -1;
}

// Skip any #! header
static int skip_hashbang(FILE *fp)
{
    char buf[sizeof("#!") - 1];
    if (fread(&buf[0], 1, sizeof(buf), fp) != sizeof(buf))
        return -1;
    if (buf[0] == '#' && buf[1] == '!') {
        for (int res; (res = getc(fp)) != '\\n'; )
            if (res == EOF)
                return -1;
    }
    rewind(fp);
    return 0;
}

// Global state
static mit_state *S;
mit_word *memory;
mit_uword memory_words, stack_words;
const char *program_name;

static void usage(void)
{
    printf("Usage: %s [OPTION...] [OBJECT-FILE ARGUMENT...]\\n"
           "\\n"
           "Run " PACKAGE_NAME " virtual machine code.\\n"
           "\\n",
           program_name);''',
              help_code,
              '''
    exit(EXIT_SUCCESS);
}


int main(int argc, char *argv[])
{
    // Unfortunately the gnulib module progname is not GPL, not LGPL.
    program_name = argv[0];

    memory_words = 0x100000U;
    stack_words = 16384U;

    // Options string starts with '+' to stop option processing at first
    // non-option, then leading ':' so as to return ':' for a missing arg,
    // not '?'
    ''',
              short_options_assignment,
              Code('''
    for (;;) {
        int this_optind = optind ? optind : 1, longindex = -1;
        int c = getopt_long(argc, argv, shortopts, longopts, &longindex);

        if (c == -1)
            break;
        else if (c == ':')
            die("option '%s' requires an argument", argv[this_optind]);
        else if (c == '?')
            die("unrecognised option '%s'\\nTry '%s --help' for more information.", argv[this_optind], program_name);
'''),
              Code(short_options_code),
              Code(long_options_code),
              Code('}'),
              '''
    // If invoked without an object file, give usage message and exit
    argc -= optind;
    argv += optind;
    if (argc < 1)
        usage();

    // Set up VM
    memory = calloc(memory_words, MIT_WORD_BYTES);
    if (memory == NULL)
        die("could not allocate virtual machine memory");
    S = mit_new_state(stack_words);
    if (S == NULL)
        die("could not allocate virtual machine state");
    mit_argc = argc;
    mit_argv = &argv[0];
    S->pc = (mit_uword)memory;

    // Load object file and report any error
    {
        FILE *fp = fopen(argv[0], "rb");
        if (fp == NULL)
            die("cannot not open file %s", argv[0]);
        int ret = skip_hashbang(fp);
        if (ret == -1)
            die("error reading file %s", argv[0]);
        off_t len = fleno(fp);
        if (len == -1)
            die("error finding size of file %s", argv[0]);
        if ((size_t)len > memory_words * MIT_WORD_BYTES)
            die("file %s is too big to fit in memory", argv[0]);
        if ((off_t)fread(memory, 1, len, fp) != len)
            die("error reading file %s", argv[0]);
        if (fclose(fp) == EOF)
            die("error closing file %s", argv[0]);
    }

    // Run
    mit_word error;
    do {
        S->ir = 0;
        error = mit_run(S);
    } while (error == MIT_ERROR_INVALID_OPCODE
             && (S->ir & MIT_OPCODE_MASK) == MIT_INSTRUCTION_JUMP
             && (error = mit_extra_instruction(S)) == MIT_ERROR_OK);

    if (error < 0 && error >= -127) {
        warn("error %zd: %s", error, error_to_msg(error));
        error = 127 - error;
    }

    mit_free_state(S);
    return error;
}'''
))

print(code)
