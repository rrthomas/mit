#!/usr/bin/env python3
# Generate code for traps.
#
# (c) Mit authors 1994-2020
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
# RISK.

from code_util import Code, copyright_banner
from params import word_bytes


# Get type sizes and inject them into instruction_gen
from type_sizes import type_sizes
import stack
stack.type_wordses.update(
    {type: (size + word_bytes - 1) // word_bytes
     for type, size in type_sizes.items()}
)

from traps import *


GENERATOR_PROGRAM = 'gen-traps'
PURPOSE = 'Execute traps.'
COPYRIGHT_YEARS = '1994-2020'


# Write the output file
code = copyright_banner(GENERATOR_PROGRAM, PURPOSE, COPYRIGHT_YEARS)
code.append('''

    #include "config.h"

    #include "mit/mit.h"
    #include "mit/features.h"'''
)

for lib in LibInstructions:
    code.append(lib.includes)

code.append('''
    #include "mit/trap-codes.h"

    #include "run.h"
'''
)

for lib in LibInstructions:
    code.append('')
    code.append(f'''\
        static mit_word trap_{lib.name.lower()}(mit_state * restrict S, mit_word opcode)
        {{
            mit_word error = MIT_ERROR_OK;'''
    )
    code.append('')

    body_code = Code()
    body_code.extend(lib.library.dispatch(Code(
        'RAISE(MIT_TRAP_ERROR_INVALID_FUNCTION);'
    )))
    body_code.append('')
    code.append(body_code)

    code.append('''
        error:
            return error;
        }'''
    )

code.append('')
code.append('''\
    mit_word mit_trap(mit_state * restrict S)
    {
        mit_word error = MIT_ERROR_OK;'''
)
code.append('')

body_code = Code()
body_code.append('mit_uword code = S->ir;')
body_code.extend(LibInstructions.dispatch(Code(
    'return MIT_TRAP_ERROR_INVALID_LIBRARY;'
), 'code'))
body_code.append('return error;')
code.append(body_code)

code.append('')
code.append('''
    error = MIT_ERROR_BREAK;
    error:
        return error;
    }'''
)

print(code)
