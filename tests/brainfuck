#!/usr/bin/env python3

import sys
import argparse

from mit.globals import *


# Process command-line arguments
parser = argparse.ArgumentParser(
    prog='brainfuck',
    description='''\
Brainfuck compiler targeting the Mit VM.

Brainfuck source is read from standard input.

https://github.com/rrthomas/mit
https://en.wikipedia.org/wiki/Brainfuck#Commands''',
    formatter_class=argparse.RawDescriptionHelpFormatter
)
parser.add_argument(
    '--version',
    action='version',
    version='''\
%(prog)s 0.2
Copyright (c) 2019 Alistair Turnbull <apt1002@mupsych.org>
Copyright (c) 2020 Reuben Thomas <rrt@sc3d.org>
brainfuck comes with ABSOLUTELY NO WARRANTY.
You may redistribute copies under the terms of the MIT/X11 License.'''
)
parser.add_argument(
    'object_file',
    metavar='OBJECT-FILE',
    help='object file to output',
)
args = parser.parse_args()


def inc(): lit(1); ass(ADD)
def dec(): lit(1); ass(NEGATE); ass(ADD)
def dup(): lit(0); ass(DUP)
def over(): lit(1); ass(DUP)
def libc(fn): lit(fn); trap(LIBC)

try:
    lit_pc_rel(0, force_long=True) # Data pointer.
    stack = [] # [(start of loop, word to patch)]
    for c in sys.stdin.read():
        if c == '>': inc()
        elif c == '<': dec()
        elif c == '+': dup(); ass(LOAD1); inc(); over(); ass(STORE1)
        elif c == '-': dup(); ass(LOAD1); dec(); over(); ass(STORE1)
        elif c == '.':
            dup() # buffer
            lit(1) # length
            libc(LibC.STDOUT)
            libc(LibC.WRITE)
            lit(1); ass(POP)
        elif c == ',':
            dup() # buffer
            lit(1) # length
            libc(LibC.STDIN)
            libc(LibC.READ)
            lit(1); ass(POP)
        elif c == '[':
            loop = label()
            print(f"{loop:#x}")
            dup()
            ass(LOAD1)
            lit_pc_rel(0, force_long=True)
            patch = assembler.pc - word_bytes
            ass(JUMPZ)
            stack.append((loop, patch))
        elif c == ']':
            loop, patch = stack.pop()
            label()
            lit_pc_rel(loop)
            ass(JUMP)
            M_word[patch] = label() - patch
    lit(MitErrorCode.OK)
    extra(THROW)
    M_word[M_word.addr + word_bytes] = label() - M_word.addr # Patch data pointer.
except ErrorCode as e:
    if e.args[0] == MitError.INVALID_MEMORY_WRITE:
        sys.exit(2)
    else:
        sys.exit(1)

save(args.object_file)
