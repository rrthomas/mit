%
% Documentation for C @PACKAGE_NAME@
%
% Reuben Thomas
%
% Started 1/12/94-8/5/95
%

\documentclass[a4paper]{article}
\usepackage[british]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{newpxtext,booktabs,hyperref,siunitx,titlesec}


% Add an extra level of sections
\setcounter{secnumdepth}{4}
\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}


% Macros

% Lay out an external interface call

\newlength{\ifacewidth}\ifacewidth=\textwidth \advance\ifacewidth by -0.1in
\newlength{\innerwidth}\innerwidth=\ifacewidth \advance\innerwidth by -0.5in
\newcommand{\ifacec}[2]{\item[]\parbox{\ifacewidth}{\hspace*{2.5mm}{\tt #1}\\[0.5ex]\hspace*{0.4in}\parbox{\innerwidth}{#2}}}

% Font for stack pictures; macro \spic includes italic correction

\newcommand{\spic}[1]{\texttt{#1\/}}

% Common stack items

\newcommand{\U}[1]{\spic{u$_{#1}$}}
\newcommand{\aaddr}[1]{\spic{a-addr$_{#1}$}}
\newcommand{\naddr}[1]{\spic{n-addr$_{#1}$}}


\title{An implementation of the @PACKAGE_NAME@ virtual machine\\for POSIX\\version @VERSION@}
\author{Reuben Thomas}
\date{1st March 2019}

\begin{document}
\maketitle


\section{Introduction}

The @PACKAGE_NAME@ virtual machine~\cite{@PACKAGE@} provides a portable virtual machine environment for study and experiment.

The @PACKAGE_NAME@ virtual machine is described in~\cite{@PACKAGE@}. This paper only
describes the features specific to this implementation.


\section{Using C @PACKAGE_NAME@}

This section describes how to compile C @PACKAGE_NAME@, and the exact manner in which
the interface calls and @PACKAGE_NAME@'s memory and registers should be accessed.


\subsection{Configuration}
\label{configuration}

C @PACKAGE_NAME@ is written in ISO C99 using POSIX-1.2001 APIs, and can be configured with a {\tt WORD\_SIZE} of $4$ or $8$. It defaults to the word size of the host system.


\subsection{Installation}

@PACKAGE_NAME@'s build system is written with GNU autotools, and the user
needs only standard POSIX utilities to run it. Installation
instructions are provided in the top-level file {\tt README.md}.


\subsection{Registers and memory}

@PACKAGE_NAME@'s registers are declared in {\tt @PACKAGE@.h}. Their names correspond to
those given in~\cite[section~2.1]{@PACKAGE@}, although some have been changed
to meet the rules for C identifiers. C @PACKAGE_NAME@
provides the interface call {\bf @PACKAGE@\_init()} to initialise a VM instance (see
section~\ref{usingcalls}).


\subsection{Extra instructions}

C @PACKAGE_NAME@ provides some extra instructions, which give access to various library functions. They take the following form:

\begin{center}
\begin{tabular}{ll} \toprule
\bf Stack effect & \bf Description \\ \midrule
\spic{i*x u — j*x} & Call the \spic{u}th function of the library, passing arguments {i*x}, with results \spic{j*x}. \\ \bottomrule
\end{tabular}
\end{center}

Error~$15$ is raised for an invalid function.


\subsubsection{@PACKAGE_NAME@}

@PACKAGE_NAME@ provides access to its own API via the {\tt LIB\_@PACKAGE_UPPER@} instruction, opcode 0x3f. This allows the current state to be controlled, or fresh states to be created and controlled. The API is mapped to the following functions:

\begin{center}
\begin{tabular}{S[table-format=2.0]lll} \toprule
\bf Code & \bf Name & \bf Stack effect & \bf Description \\ \midrule
0x0 & {\tt CURRENT\_STATE} & \spic{— n-addr} & a pointer to the current {\tt state} \\
0x1 & {\tt LOAD\_WORD} & \spic{n-addr a-addr — x n} & \\
0x2 & {\tt STORE\_WORD} & \spic{n-addr a-addr x — n} & \\
0x3 & {\tt LOAD\_BYTE} & \spic{n-addr addr x n} & \\
0x4 & {\tt STORE\_BYTE} & \spic{n-addr addr x — n} & \\
0x5 & {\tt REALLOC\_MEMORY} & \spic{\naddr1 \naddr2 u f — addr} & \\
0x6 & {\tt REALLOC\_STACK} & \spic{\naddr1 \naddr2 u f — addr} & \\
0x7 & {\tt NATIVE\_ADDRESS\_OF\_RANGE} & \spic{\naddr1 addr f — \naddr2} & \\
0x8 & {\tt RUN} & \spic{n-addr — n} & \\
0x9 & {\tt SINGLE\_STEP} & \spic{n-addr — n} & \\
0xa & {\tt LOAD\_OBJECT} & \spic{n-addr fid addr — n} & \\
0xb & {\tt INIT} & \spic{a-addr \U1 \U2 \U3 — n-addr} & \\
0xc & {\tt DESTROY} & \spic{n-addr} & \\
0xd & {\tt REGISTER\_ARGS} & \spic{n-addr n-addr n — n} & \\
\bottomrule
\end{tabular}
\end{center}


\subsubsection{Standard library}

Standard C runtime and library functionality is accessed via the {\tt LIB\_C} instruction, opcode 0x3e.

\paragraph{Command-line arguments}

Some functions are provided to access command-line arguments passed to C @PACKAGE_NAME@ (excluding any that it interprets itself).

\begin{center}
\begin{tabular}{S[table-format=2.0]lll} \toprule
\bf Code & \bf Name & \bf Stack effect & \bf Description \\ \midrule
0x0 & {\tt ARGC} & \spic{— u} & the number of arguments \\
0x1 & {\tt ARG\_LEN} & \spic{\U1 — \U2} & the length of the \spic{u1}th argument \\
0x2 & {\tt ARG\_COPY} & \spic{\U1 c-addr \U2 — \U3} & copy argument \U1 to the buffer of length \U2 at \spic{c-addr}, leaving the number of characters actually copied as \U3 \\
 \bottomrule
\end{tabular}
\end{center}

\paragraph{Standard I/O streams}

These extra instructions provide access to POSIX standard input, output and error. Each call returns a corresponding file identifier.

\begin{center}
\begin{tabular}{S[table-format=2.0]l} \toprule
\bf Opcode & \bf POSIX file descriptor \\ \midrule
0x3 & {\tt STDIN\_FILENO} \\
0x4 & {\tt STDOUT\_FILENO} \\
0x5 & {\tt STDERR\_FILENO} \\ \bottomrule
\end{tabular}
\end{center}

\paragraph{File system}

% FIXME: document these functions properly

\begin{center}
\begin{tabular}{S[table-format=2.0]l} \toprule
\bf Opcode & \bf Forth word \\ \midrule
0x6 & {\tt OPEN-FILE} \\
0x7 & {\tt CLOSE-FILE} \\
0x8 & {\tt READ-FILE} \\
0x9 & {\tt WRITE-FILE} \\
0xa & {\tt FILE-POSITION} \\
0xb & {\tt REPOSITION-FILE} \\
0xc & {\tt FLUSH-FILE} \\
0xd & {\tt RENAME-FILE} \\
0xe & {\tt DELETE-FILE} \\
0xf & {\tt FILE-SIZE} \\
0x10 & {\tt RESIZE-FILE} \\
0x11 & {\tt FILE-STATUS} \\
\bottomrule
\end{tabular}
\end{center}

The implementation-dependent word returned by {\tt FILE-STATUS} contains the POSIX protection bits, given by the {\tt st\_mode} member of the {\tt struct stat} returned for the given file descriptor.

File access methods are bit-masks, composed as follows:

\begin{center}
\begin{tabular}{cc} \toprule
\rule[-2mm]{0mm}{6mm}\bf Bit value & \bf Meaning \\ \midrule
1 & read \\
2 & write \\
4 & binary mode \\ \bottomrule
\end{tabular}
\end{center}

To create a file, set both read and write bits to zero when calling {\tt OPEN-FILE}.


\subsection{Using the interface calls}
\label{usingcalls}

The operation of the specified interface calls is given in~\cite{@PACKAGE@}. Here, the C prototypes corresponding to the idealised prototypes used in~\cite{@PACKAGE@} are given. The names are prefixed with {\bf @PACKAGE@\_}. The first argument to most routines is a {\tt @PACKAGE\_state *}, as returned by {\tt @PACKAGE@\_init}.

\begin{description}
\ifacec{uint8\_t *native\_address\_of\_range(@PACKAGE@\_state *state, @PACKAGE@\_UWORD address, @PACKAGE@\_UWORD length)}{Returns {\tt NULL} when the address range is not entirely valid.}
\ifacec{@PACKAGE@\_state *state, @PACKAGE@\_WORD run(@PACKAGE@\_state *state)}{The reason code returned by {\bf @PACKAGE@\_run()} is a @PACKAGE_NAME@
word.}
\ifacec{@PACKAGE@\_state *state, @PACKAGE@\_WORD @PACKAGE@\_single\_step(@PACKAGE@\_state *state)}{The reason code returned by {\bf @PACKAGE@\_single\_step()}
is a @PACKAGE_NAME@ word.}
\ifacec{ptrdiff\_t @PACKAGE@\_load\_object(@PACKAGE@\_state *state, @PACKAGE@\_UWORD address, int fd)}{If a file system error
occurs, the return code is $-3$. If the endism of the object file does not match {\tt ENDISM}, the return code is $-4$. If the word size of the object file is not {\tt WORD\_SIZE}, the return code is $-5$. As an extension to the specification, if an object file starts with the bytes $35$, $33$ (\texttt{\#!}), then it is assumed to be the start of a UNIX-style “hash bang” line, and the file contents up to and including the first newline character ($10$) is ignored.}
\end{description}

In addition to the required interface calls C @PACKAGE_NAME@ provides an initialisation routine {\bf @PACKAGE@\_init()} which, given a word array and its size, initialises @PACKAGE_NAME@:

\begin{description}
\ifacec{@PACKAGE@\_state *@PACKAGE@\_init(size\_t memory\_size, size\_t stack\_size)}{{\tt memory\_size} is
the size of {\tt b\_array} in {\em words} (not bytes); similarly, {\tt stack\_size} gives the size of the stack in words; these are allocated by {\tt @PACKAGE@\_init}. The return value is {\tt NULL} if memory cannot be allocated, or if any requested size is too large, and a pointer to a new state otherwise.
All the registers are initialised as per~\cite{@PACKAGE@}.}
\ifacec{int @PACKAGE@\_realloc\_memory(@PACKAGE@\_state *state, @PACKAGE@\_UWORD size)}{Resize the memory to the given {\tt size}. Any new memory is zeroed. Returns $0$ on success or $-1$ if the requested size of memory cannot be allocated.}
\ifacec{int @PACKAGE@\_realloc\_stack(@PACKAGE@\_state *state, @PACKAGE@\_UWORD size)}{Resize the stack to the given {\tt size}. Any new memory is zeroed. Returns $0$ on success or $-1$ if the requested size of memory cannot be allocated.}
\end{description}

The following routines give easier access to @PACKAGE_NAME@’s address space at the byte and word level. On success, they return $0$, and on failure, the relevant error code.

\begin{description}
\ifacec{int @PACKAGE@\_load\_word(@PACKAGE@\_state *state, @PACKAGE@\_UWORD address, @PACKAGE@\_WORD *value)}{Load the word at the given address into the given {\tt @PACKAGE@\_WORD *}.}
\ifacec{int @PACKAGE@\_store\_word(@PACKAGE@\_state *state, @PACKAGE@\_UWORD address, @PACKAGE@\_WORD value)}{Store the given {\tt WORD} value at the given address.}
\ifacec{int @PACKAGE@\_load\_byte(@PACKAGE@\_state *state, @PACKAGE@\_UWORD address, @PACKAGE@\_BYTE *value)}{Load the byte at the given address into the given {\tt @PACKAGE@\_BYTE *}.}
\ifacec{int @PACKAGE@\_store\_byte(@PACKAGE@\_state *state, @PACKAGE@\_UWORD address, @PACKAGE@\_BYTE value)}{Store the given {\tt @PACKAGE@\_BYTE} value at the given address.}
\end{description}

The following routines give access to @PACKAGE_NAME@’s stacks. On success, they return $0$, and on failure, the relevant error code.

\begin{description}
\ifacec{int @PACKAGE@\_load\_stack(@PACKAGE@\_state *state, @PACKAGE@\_UWORD pos, @PACKAGE@\_WORD *value)}{Load the word at the given position of the data stack into the given {\tt @PACKAGE@\_WORD *}.}
\ifacec{int @PACKAGE@\_store\_stack(@PACKAGE@\_state *state, @PACKAGE@\_UWORD pos, @PACKAGE@\_WORD value)}{Store the given {\tt WORD} value at the given position in the data stack.}
\ifacec{int @PACKAGE@\_pop\_stack(@PACKAGE@\_state *state, @PACKAGE@\_WORD *value)}{Pop the top word off the data stack, decrementing its depth, into the given {\tt @PACKAGE@\_WORD *}.}
\ifacec{int @PACKAGE@\_push\_stack(@PACKAGE@\_state *state, @PACKAGE@\_WORD value)}{Push the given {\tt @PACKAGE@\_WORD} value on to the data stack of the given size, incrementing its depth.}
\end{description}

The following routine allows the calling program to register command-line arguments that can be retrieved by the {\tt ARGC} and {\tt ARG\_COPY} extra instructions.

\begin{description}
\ifacec{int @PACKAGE@\_register\_args(@PACKAGE@\_state *state, int argc, char *argv[])}{Maps the given arguments register, which has the same format as that supplied to {\bf main()}, into @PACKAGE_NAME@’s memory. Returns $0$ on success and $-1$ if memory could not be allocated, or $-2$ if an argument could not be mapped to @PACKAGE_NAME@’s address space.}
\end{description}

Programs which use C @PACKAGE_NAME@'s interface must {\tt \#include} the header file
{\tt @PACKAGE@/@PACKAGE@.h} and be linked with the @PACKAGE_NAME@ library. {\tt @PACKAGE@/opcodes.h}, which contains an enumeration type of @PACKAGE_NAME@'s instruction set,
may also be useful; it is not documented here.


\subsection{Other extras provided by C @PACKAGE_NAME@}

Other useful extras are provided in {\tt @PACKAGE@/@PACKAGE@.h}. These are used internally, and are thought to be useful, but may change at any time, so their stability should not be relied on.


\bibliographystyle{plain}
\bibliography{rrt}


\end{document}
